import{P as ref,v as onBeforeMount,ah as watch,ai as isRef,aj as reactive,x as onBeforeUnmount,ak as computed,al as isReactive,am as isReadonly,V as unref,an as inject,ao as provide,ap as getCurrentInstance,aq as nextTick}from"./popup.71dac307.js";function unwrapObj(obj){let ignoreKeys=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Object.keys(obj).reduce(((o,k)=>(ignoreKeys.includes(k)||(o[k]=unref(obj[k])),o)),{})}function isFunction$1(val){return"function"==typeof val}function isProxy(value){return isReactive(value)||isReadonly(value)}function callRule(rule,value,siblingState,instance){return rule.call(instance,unref(value),unref(siblingState),instance)}function normalizeValidatorResponse(result){return void 0!==result.$valid?!result.$valid:!result}function createValidatorResult(rule,model,$dirty,config,instance,validatorName,propertyKey,propertyPath,siblingState,$lastInvalidState,$lastCommittedOn){const $pending=ref(!1),$params=rule.$params||{},$response=ref(null);let $invalid,$unwatch;rule.$async?({$invalid:$invalid,$unwatch:$unwatch}=function(rule,model,$pending,$dirty,_ref,$response,instance){let{$lazy:$lazy,$rewardEarly:$rewardEarly}=_ref,watchTargets=arguments.length>7&&void 0!==arguments[7]?arguments[7]:[],siblingState=arguments.length>8?arguments[8]:void 0,$lastInvalidState=arguments.length>9?arguments[9]:void 0,$lastCommittedOn=arguments.length>10?arguments[10]:void 0;const $invalid=ref(!!$dirty.value),$pendingCounter=ref(0);$pending.value=!1;const $unwatch=watch([model,$dirty].concat(watchTargets,$lastCommittedOn),(()=>{if($lazy&&!$dirty.value||$rewardEarly&&!$lastInvalidState.value&&!$pending.value)return;let ruleResult;try{ruleResult=callRule(rule,model,siblingState,instance)}catch(err){ruleResult=Promise.reject(err)}$pendingCounter.value++,$pending.value=!!$pendingCounter.value,$invalid.value=!1,Promise.resolve(ruleResult).then((data=>{$pendingCounter.value--,$pending.value=!!$pendingCounter.value,$response.value=data,$invalid.value=normalizeValidatorResponse(data)})).catch((error=>{$pendingCounter.value--,$pending.value=!!$pendingCounter.value,$response.value=error,$invalid.value=!0}))}),{immediate:!0,deep:"object"==typeof model});return{$invalid:$invalid,$unwatch:$unwatch}}(rule.$validator,model,$pending,$dirty,config,$response,instance,rule.$watchTargets,siblingState,$lastInvalidState,$lastCommittedOn)):({$invalid:$invalid,$unwatch:$unwatch}=function(rule,model,$dirty,_ref2,$response,instance,siblingState,$lastInvalidState){let{$lazy:$lazy,$rewardEarly:$rewardEarly}=_ref2;return{$unwatch:()=>({}),$invalid:computed((()=>{if($lazy&&!$dirty.value||$rewardEarly&&!$lastInvalidState.value)return!1;let returnValue=!0;try{const result=callRule(rule,model,siblingState,instance);$response.value=result,returnValue=normalizeValidatorResponse(result)}catch(err){$response.value=err}return returnValue}))}}(rule.$validator,model,$dirty,config,$response,instance,siblingState,$lastInvalidState));const message=rule.$message;return{$message:isFunction$1(message)?computed((()=>message(unwrapObj({$pending:$pending,$invalid:$invalid,$params:unwrapObj($params),$model:model,$response:$response,$validator:validatorName,$propertyPath:propertyPath,$property:propertyKey})))):message||"",$params:$params,$pending:$pending,$invalid:$invalid,$response:$response,$unwatch:$unwatch}}function _empty(){}function _call(body,then,direct){if(direct)return then?then(body()):body();try{var result=Promise.resolve(body());return then?result.then(then):result}catch(e){return Promise.reject(e)}}function setValidations(_ref){const $validate=(f=function(){return $touch(),then=function(){return _call(nextTick,(function(){return new Promise((resolve=>{if(!$pending.value)return resolve(!$invalid.value);const unwatch=watch($pending,(()=>{resolve(!$invalid.value),unwatch()}))}))}))},(result=function(){if(mergedConfig.$rewardEarly)return $commit(),_call(nextTick,_empty,direct);var direct}())&&result.then?result.then(then):then(result);var then,result},function(){for(var args=[],i=0;i<arguments.length;i++)args[i]=arguments[i];try{return Promise.resolve(f.apply(this,args))}catch(e){return Promise.reject(e)}});var f;let{validations:validations,state:state,key:key,parentKey:parentKey,childResults:childResults,resultsCache:resultsCache,globalConfig:globalConfig={},instance:instance,externalResults:externalResults}=_ref;const path=parentKey?`${parentKey}.${key}`:key,{rules:rules,nestedValidators:nestedValidators,config:config}=function(){const validations=unref(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),validationKeys=Object.keys(validations),rules={},nestedValidators={},config={};return validationKeys.forEach((key=>{const v=validations[key];switch(!0){case isFunction$1(v.$validator):rules[key]=v;break;case isFunction$1(v):rules[key]={$validator:v};break;case key.startsWith("$"):config[key]=v;break;default:nestedValidators[key]=v}})),{rules:rules,nestedValidators:nestedValidators,config:config}}(validations),mergedConfig=Object.assign({},globalConfig,config),nestedState=key?computed((()=>{const s=unref(state);return s?unref(s[key]):void 0})):state,cachedExternalResults=Object.assign({},unref(externalResults)||{}),nestedExternalResults=computed((()=>{const results2=unref(externalResults);return key?results2?unref(results2[key]):void 0:results2})),results=function(rules,model,key,resultsCache,path,config,instance,externalResults,siblingState){const ruleKeys=Object.keys(rules),cachedResult=resultsCache.get(path,rules),$dirty=ref(!1),$lastInvalidState=ref(!1),$lastCommittedOn=ref(0);if(cachedResult){if(!cachedResult.$partial)return cachedResult;cachedResult.$unwatch(),$dirty.value=cachedResult.$dirty.value}const result={$dirty:$dirty,$path:path,$touch:()=>{$dirty.value||($dirty.value=!0)},$reset:()=>{$dirty.value&&($dirty.value=!1)},$commit:()=>{}};return ruleKeys.length?(ruleKeys.forEach((ruleKey=>{result[ruleKey]=createValidatorResult(rules[ruleKey],model,result.$dirty,config,instance,ruleKey,key,path,siblingState,$lastInvalidState,$lastCommittedOn)})),result.$externalResults=computed((()=>externalResults.value?[].concat(externalResults.value).map(((stringError,index)=>({$propertyPath:path,$property:key,$validator:"$externalResults",$uid:`${path}-externalResult-${index}`,$message:stringError,$params:{},$response:null,$pending:!1}))):[])),result.$invalid=computed((()=>{const r=ruleKeys.some((ruleKey=>unref(result[ruleKey].$invalid)));return $lastInvalidState.value=r,!!result.$externalResults.value.length||r})),result.$pending=computed((()=>ruleKeys.some((ruleKey=>unref(result[ruleKey].$pending))))),result.$error=computed((()=>!!result.$dirty.value&&(result.$pending.value||result.$invalid.value))),result.$silentErrors=computed((()=>ruleKeys.filter((ruleKey=>unref(result[ruleKey].$invalid))).map((ruleKey=>{const res=result[ruleKey];return reactive({$propertyPath:path,$property:key,$validator:ruleKey,$uid:`${path}-${ruleKey}`,$message:res.$message,$params:res.$params,$response:res.$response,$pending:res.$pending})})).concat(result.$externalResults.value))),result.$errors=computed((()=>result.$dirty.value?result.$silentErrors.value:[])),result.$unwatch=()=>ruleKeys.forEach((ruleKey=>{result[ruleKey].$unwatch()})),result.$commit=()=>{$lastInvalidState.value=!0,$lastCommittedOn.value=Date.now()},resultsCache.set(path,rules,result),result):(cachedResult&&resultsCache.set(path,rules,result),result)}(rules,nestedState,key,resultsCache,path,mergedConfig,instance,nestedExternalResults,state),nestedResults=function(validations,nestedState,path,resultsCache,config,instance,nestedExternalResults){const nestedValidationKeys=Object.keys(validations);return nestedValidationKeys.length?nestedValidationKeys.reduce(((results,nestedKey)=>(results[nestedKey]=setValidations({validations:validations[nestedKey],state:nestedState,key:nestedKey,parentKey:path,resultsCache:resultsCache,globalConfig:config,instance:instance,externalResults:nestedExternalResults}),results)),{}):{}}(nestedValidators,nestedState,path,resultsCache,mergedConfig,instance,nestedExternalResults),{$dirty:$dirty,$errors:$errors,$invalid:$invalid,$anyDirty:$anyDirty,$error:$error,$pending:$pending,$touch:$touch,$reset:$reset,$silentErrors:$silentErrors,$commit:$commit}=function(results,nestedResults,childResults){const allResults=computed((()=>[nestedResults,childResults].filter((res=>res)).reduce(((allRes,res)=>allRes.concat(Object.values(unref(res)))),[]))),$dirty=computed({get:()=>results.$dirty.value||!!allResults.value.length&&allResults.value.every((r=>r.$dirty)),set(v){results.$dirty.value=v}}),$silentErrors=computed((()=>{const modelErrors=unref(results.$silentErrors)||[],nestedErrors=allResults.value.filter((result=>(unref(result).$silentErrors||[]).length)).reduce(((errors,result)=>errors.concat(...result.$silentErrors)),[]);return modelErrors.concat(nestedErrors)})),$errors=computed((()=>{const modelErrors=unref(results.$errors)||[],nestedErrors=allResults.value.filter((result=>(unref(result).$errors||[]).length)).reduce(((errors,result)=>errors.concat(...result.$errors)),[]);return modelErrors.concat(nestedErrors)})),$invalid=computed((()=>allResults.value.some((r=>r.$invalid))||unref(results.$invalid)||!1)),$pending=computed((()=>allResults.value.some((r=>unref(r.$pending)))||unref(results.$pending)||!1)),$anyDirty=computed((()=>allResults.value.some((r=>r.$dirty))||allResults.value.some((r=>r.$anyDirty))||$dirty.value)),$error=computed((()=>!!$dirty.value&&($pending.value||$invalid.value))),$touch=()=>{results.$touch(),allResults.value.forEach((result=>{result.$touch()}))};return allResults.value.length&&allResults.value.every((nr=>nr.$dirty))&&$touch(),{$dirty:$dirty,$errors:$errors,$invalid:$invalid,$anyDirty:$anyDirty,$error:$error,$pending:$pending,$touch:$touch,$reset:()=>{results.$reset(),allResults.value.forEach((result=>{result.$reset()}))},$silentErrors:$silentErrors,$commit:()=>{results.$commit(),allResults.value.forEach((result=>{result.$commit()}))}}}(results,nestedResults,childResults),$model=key?computed({get:()=>unref(nestedState),set:val=>{$dirty.value=!0;const s=unref(state),external=unref(externalResults);external&&(external[key]=cachedExternalResults[key]),isRef(s[key])?s[key].value=val:s[key]=val}}):null;return key&&mergedConfig.$autoDirty&&watch(nestedState,(()=>{$dirty.value||$touch();const external=unref(externalResults);external&&(external[key]=cachedExternalResults[key])}),{flush:"sync"}),reactive(Object.assign({},results,{$model:$model,$dirty:$dirty,$error:$error,$errors:$errors,$invalid:$invalid,$anyDirty:$anyDirty,$pending:$pending,$touch:$touch,$reset:$reset,$path:path||"__root",$silentErrors:$silentErrors,$validate:$validate,$commit:$commit},childResults&&{$getResultsForChild:function(key2){return(childResults.value||{})[key2]},$clearExternalResults:function(){isRef(externalResults)?externalResults.value=cachedExternalResults:0===Object.keys(cachedExternalResults).length?Object.keys(externalResults).forEach((k=>{delete externalResults[k]})):Object.assign(externalResults,cachedExternalResults)}},nestedResults))}class ResultsStorage{constructor(){this.storage=new Map}set(path,rules,result){this.storage.set(path,{rules:rules,result:result})}checkRulesValidity(path,rules,storedRules){const storedRulesKeys=Object.keys(storedRules),newRulesKeys=Object.keys(rules);if(newRulesKeys.length!==storedRulesKeys.length)return!1;return!!newRulesKeys.every((ruleKey=>storedRulesKeys.includes(ruleKey)))&&newRulesKeys.every((ruleKey=>!rules[ruleKey].$params||Object.keys(rules[ruleKey].$params).every((paramKey=>unref(storedRules[ruleKey].$params[paramKey])===unref(rules[ruleKey].$params[paramKey])))))}get(path,rules){const storedRuleResultPair=this.storage.get(path);if(!storedRuleResultPair)return;const{rules:storedRules,result:result}=storedRuleResultPair,isValidCache=this.checkRulesValidity(path,rules,storedRules),$unwatch=result.$unwatch?result.$unwatch:()=>({});return isValidCache?result:{$dirty:result.$dirty,$partial:!0,$unwatch:$unwatch}}}const CollectFlag={COLLECT_ALL:!0,COLLECT_NONE:!1},VuelidateInjectChildResults=Symbol("vuelidate#injectChildResults"),VuelidateRemoveChildResults=Symbol("vuelidate#removeChildResults");function nestedValidations(_ref){let{$scope:$scope,instance:instance}=_ref;const childResultsRaw={},childResultsKeys=ref([]),childResults=computed((()=>childResultsKeys.value.reduce(((results,key)=>(results[key]=unref(childResultsRaw[key]),results)),{})));instance.__vuelidateInjectInstances=[].concat(instance.__vuelidateInjectInstances||[],(function(results,_ref2){let{$registerAs:key,$scope:childScope,$stopPropagation:$stopPropagation}=_ref2;$stopPropagation||$scope===CollectFlag.COLLECT_NONE||childScope===CollectFlag.COLLECT_NONE||$scope!==CollectFlag.COLLECT_ALL&&$scope!==childScope||(childResultsRaw[key]=results,childResultsKeys.value.push(key))})),instance.__vuelidateRemoveInstances=[].concat(instance.__vuelidateRemoveInstances||[],(function(key){childResultsKeys.value=childResultsKeys.value.filter((childKey=>childKey!==key)),delete childResultsRaw[key]}));const sendValidationResultsToParent=inject(VuelidateInjectChildResults,[]);provide(VuelidateInjectChildResults,instance.__vuelidateInjectInstances);const removeValidationResultsFromParent=inject(VuelidateRemoveChildResults,[]);return provide(VuelidateRemoveChildResults,instance.__vuelidateRemoveInstances),{childResults:childResults,sendValidationResultsToParent:sendValidationResultsToParent,removeValidationResultsFromParent:removeValidationResultsFromParent}}function ComputedProxyFactory(target){return new Proxy(target,{get:(target2,prop)=>"object"==typeof target2[prop]?ComputedProxyFactory(target2[prop]):computed((()=>target2[prop]))})}function useVuelidate(validations,state){let globalConfig=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};1===arguments.length&&(globalConfig=validations,validations=void 0,state=void 0);let{$registerAs:$registerAs,$scope:$scope=CollectFlag.COLLECT_ALL,$stopPropagation:$stopPropagation,$externalResults:$externalResults,currentVueInstance:currentVueInstance}=globalConfig;const instance=currentVueInstance||getCurrentInstance(),componentOptions=instance?instance.proxy.$options:{};if(!$registerAs&&instance){const uid=instance.uid||instance._uid;$registerAs=`_vuelidate_${uid}`}const validationResults=ref({}),resultsCache=new ResultsStorage,{childResults:childResults,sendValidationResultsToParent:sendValidationResultsToParent,removeValidationResultsFromParent:removeValidationResultsFromParent}=instance?nestedValidations({$scope:$scope,instance:instance}):{childResults:ref({})};if(!validations&&componentOptions.validations){const rules=componentOptions.validations;state=ref({}),onBeforeMount((()=>{state.value=instance.proxy,watch((()=>isFunction$1(rules)?rules.call(state.value,new ComputedProxyFactory(state.value)):rules),(validations2=>{validationResults.value=setValidations({validations:validations2,state:state,childResults:childResults,resultsCache:resultsCache,globalConfig:globalConfig,instance:instance.proxy,externalResults:$externalResults||instance.proxy.vuelidateExternalResults})}),{immediate:!0})})),globalConfig=componentOptions.validationsConfig||globalConfig}else{const validationsWatchTarget=isRef(validations)||isProxy(validations)?validations:reactive(validations||{});watch(validationsWatchTarget,(newValidationRules=>{validationResults.value=setValidations({validations:newValidationRules,state:state,childResults:childResults,resultsCache:resultsCache,globalConfig:globalConfig,instance:instance?instance.proxy:{},externalResults:$externalResults})}),{immediate:!0})}return instance&&(sendValidationResultsToParent.forEach((f=>f(validationResults,{$registerAs:$registerAs,$scope:$scope,$stopPropagation:$stopPropagation}))),onBeforeUnmount((()=>removeValidationResultsFromParent.forEach((f=>f($registerAs)))))),computed((()=>Object.assign({},unref(validationResults.value),childResults.value)))}function isFunction(val){return"function"==typeof val}function isObject(o){return null!==o&&"object"==typeof o&&!Array.isArray(o)}function normalizeValidatorObject(validator){return isFunction(validator.$validator)?Object.assign({},validator):{$validator:validator}}function unwrapValidatorResponse(result){return"object"==typeof result?result.$valid:result}function unwrapNormalizedValidator(validator){return validator.$validator||validator}function withMessage($message,$validator){if(!isFunction($message)&&"string"!=typeof unref($message))throw new Error('[@vuelidate/validators]: First parameter to "withMessage" should be string or a function returning a string, provided '+typeof $message);if(!isObject($validator)&&!isFunction($validator))throw new Error("[@vuelidate/validators]: Validator must be a function or object with $validator parameter");const validatorObj=normalizeValidatorObject($validator);return validatorObj.$message=$message,validatorObj}const req=value=>{if(value=unref(value),Array.isArray(value))return!!value.length;if(null==value)return!1;if(!1===value)return!0;if(value instanceof Date)return!isNaN(value.getTime());if("object"==typeof value){for(let _ in value)return!0;return!1}return!!String(value).length},len=value=>(value=unref(value),Array.isArray(value)?value.length:"object"==typeof value?Object.keys(value).length:String(value).length);function regex(){for(var _len=arguments.length,expr=new Array(_len),_key=0;_key<_len;_key++)expr[_key]=arguments[_key];return value=>(value=unref(value),!req(value)||expr.every((reg=>reg.test(value))))}var common=Object.freeze({__proto__:null,withParams:function($params,$validator){if(!isObject($params))throw new Error('[@vuelidate/validators]: First parameter to "withParams" should be an object, provided '+typeof $params);if(!isObject($validator)&&!isFunction($validator))throw new Error("[@vuelidate/validators]: Validator must be a function or object with $validator parameter");const validatorObj=normalizeValidatorObject($validator);return validatorObj.$params=Object.assign({},validatorObj.$params||{},$params),validatorObj},withMessage:withMessage,withAsync:function($validator){let $watchTargets=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const validatorObj=normalizeValidatorObject($validator);return Object.assign({},validatorObj,{$async:!0,$watchTargets:$watchTargets})},forEach:function(validators){return{$validator(collection){for(var _len=arguments.length,others=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)others[_key-1]=arguments[_key];return unref(collection).reduce(((previous,collectionItem)=>{const collectionEntryResult=Object.entries(collectionItem).reduce(((all,_ref)=>{let[property,$model]=_ref;const innerValidators=validators[property]||{},propertyResult=Object.entries(innerValidators).reduce(((all2,_ref2)=>{let[validatorName,currentValidator]=_ref2;const $response=unwrapNormalizedValidator(currentValidator).call(this,$model,collectionItem,...others),$valid=unwrapValidatorResponse($response);if(all2.$data[validatorName]=$response,all2.$data.$invalid=!$valid||!!all2.$data.$invalid,all2.$data.$error=all2.$data.$invalid,!$valid){let $message=currentValidator.$message||"";const $params=currentValidator.$params||{};"function"==typeof $message&&($message=$message({$pending:!1,$invalid:!$valid,$params:$params,$model:$model,$response:$response})),all2.$errors.push({$property:property,$message:$message,$params:$params,$response:$response,$model:$model,$pending:!1,$validator:validatorName})}return{$valid:all2.$valid&&$valid,$data:all2.$data,$errors:all2.$errors}}),{$valid:!0,$data:{},$errors:[]});return all.$data[property]=propertyResult.$data,all.$errors[property]=propertyResult.$errors,{$valid:all.$valid&&propertyResult.$valid,$data:all.$data,$errors:all.$errors}}),{$valid:!0,$data:{},$errors:{}});return{$valid:previous.$valid&&collectionEntryResult.$valid,$data:previous.$data.concat(collectionEntryResult.$data),$errors:previous.$errors.concat(collectionEntryResult.$errors)}}),{$valid:!0,$data:[],$errors:[]})},$message:_ref3=>{let{$response:$response}=_ref3;return $response?$response.$errors.map((context=>Object.values(context).map((errors=>errors.map((error=>error.$message)))).reduce(((a,b)=>a.concat(b)),[]))):[]}}},req:req,len:len,regex:regex,unwrap:unref,unwrapNormalizedValidator:unwrapNormalizedValidator,unwrapValidatorResponse:unwrapValidatorResponse,normalizeValidatorObject:normalizeValidatorObject});regex(/^[a-zA-Z]*$/),regex(/^[a-zA-Z0-9]*$/),regex(/^\d*(\.\d+)?$/);var email={$validator:regex(/^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i),$message:"Value is not a valid email address",$params:{type:"email"}};function maxLength(max){return{$validator:(length=max,value=>!req(value)||len(value)<=unref(length)),$message:_ref=>{let{$params:$params}=_ref;return`The maximum length allowed is ${$params.max}`},$params:{max:max,type:"maxLength"}};var length}function minLength(min){return{$validator:(length=min,value=>!req(value)||len(value)>=unref(length)),$message:_ref=>{let{$params:$params}=_ref;return`This field should be at least ${$params.min} characters long`},$params:{min:min,type:"minLength"}};var length}var required={$validator:function(value){return"string"==typeof value&&(value=value.trim()),req(value)},$message:"Value is required",$params:{type:"required"}};function createI18nMessage(_ref){let{t:t,messagePath:messagePath=(_ref2=>{let{$validator:$validator}=_ref2;return`validations.${$validator}`}),messageParams:messageParams=(params=>params)}=_ref;return function(validator){let{withArguments:withArguments=!1,messagePath:localMessagePath=messagePath,messageParams:localMessageParams=messageParams}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function message(props){return t(localMessagePath(props),localMessageParams(Object.assign({model:props.$model,property:props.$property,pending:props.$pending,invalid:props.$invalid,response:props.$response,validator:props.$validator,propertyPath:props.$propertyPath},props.$params)))}return withArguments&&"function"==typeof validator?function(){return withMessage(message,validator(...arguments))}:withMessage(message,validator)}}regex(/^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i),regex(/(^[0-9]*$)|(^-[0-9]+$)/),regex(/^[-]?\d*(\.\d+)?$/);export{maxLength as a,createI18nMessage as b,common as c,email as e,minLength as m,required as r,useVuelidate as u};
